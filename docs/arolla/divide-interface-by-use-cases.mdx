import {Severity, SeverityLevels} from "../../src/components/practice/severity/Severity";
import {Categories} from "../../src/components/practice/categories/Categories";
import {Example} from "../../src/components/practice/example/Example";


# Divide interface by use cases

<Severity severity={SeverityLevels.MEDIUM} />

---

<Categories categories={["SOLID","csharp"]} />

##### What is it?
This practice is activated when an interface contains methods that are unrelated or serve different user goals, which can be recognized by a cluttered interface with methods that don't logically belong together.

A bad smell is when interfaces contains more than 10 methods.

##### Why apply it?
Dividing interfaces by use cases enhances readability, maintainability, and usability by ensuring that each interface serves a clear and specific purpose, reducing complexity and improving codebase modularity.

##### How to fix it?
Refactor the interface by segmenting it into smaller, more focused interfaces, each capturing specific use cases or logical groupings of methods.

#### Read more:
[https://martinfowler.com/bliki/RoleInterface.html](https://martinfowler.com/bliki/RoleInterface.html)

## Examples

### Example 1:

<!-- #example -->

#### Negative

<!-- #example_negative_description -->
Incorrect implementation that violates the practice.

<!-- #example_negative_code -->
```cs
namespace Packmind;

public class ReadWriteRepository : IReadWriteRepository
{
    public IList<Order> Read()
    {
        return new List<Order>();
    }

    public void WriteOrder(Order order)
    {
        
    }
}

public interface IReadWriteRepository
{
    IList<Order> Read();
    void WriteOrder(Order order);
}
```